*ストリーム指向のストレージDrip

この章では筆者が最近夢中になっているストリーム指向のストレージ、Dripについて紹介します。Dripはストレージであると同時に、プロセス間を協調のメカニズムでもあります。このくだりを聴いてもRindaとの共通部分が多くあると感じるでしょう。実際にRindaのアプリケーションを書いた経験を元にして書かれました。DripはRindaを置き換えるものではありません。どちらかというとオブジェクトの貯蔵庫であって、オブジェクト指向データベース、Key Value Storeやマルチディメンジョンのリストなど一連のストレージの習作を出発点としました。


**Dripとはなにか

Dripは追記型のストレージの一種で、Rubyオブジェクトを時系列にログします。Dripにはオブジェクトの追記のみ可能で、削除や更新はできません。dRubyのRMIを考慮した、局所的で安価なブラウズ用APIを用意してあります。オブジェクトのまとめ転送や、簡単なパターンによるフィルタ、シークをなど、です。
また、Dripはプロセス間の同期メカニズムでもあります。新しいオブジェクトの到着を待合せることができます。Dripでは一度保存されたオブジェクトは変化することはありません。複数のプロセスがばらばらの時刻に読み出した情報はどれも同じものですし、誰かが読んだオブジェクトを別の誰かが変更することはありません。この特性は分散ファイルシステムでよく見られる特性で、情報を排他的にアクセスしなくてはならない状況を減らすことができます。

Dripはちょっとしたオブジェクトの保存先であり、プロセス間通信、バッチ処理のエーテルであり、ライフログです。単純な仕組みであるため、さまざまな用途への応用が考えられますし、それ故に使い途を想像するのが難しいとも言えます。私のDripを次のようなアプリケーションに使いました。

- バッチ処理のミドルウェア
- Wikiシステムのストレージと全文検索
- Twitterのタイムラインのアーカイブとbotフレームワーク
- irbでの作業中のメモ

ちょっと雲をつかむような感じですね。次の節から、身近な同期メカニズムであるQueue、身近なオブジェクトの貯蔵庫であるHashとの違いをそれぞれ見ながら、Dripを紹介します。

**Queueとの違い

まずQueueと比較しながらDripにおけるプロセス間の協調の違いを見てましょう。

ここでのQueueとはRubyに付属のQueueクラスです。QueueはFIFOのバッファで、要素は任意のオブジェクトです。Queueにオブジェクトを追加するのはpush、オブジェクトを取り出すのはpopです。popはオブジェクトを返すと同時に、Queueの中からそのオブジェクトを削除します。
同時に複数のスレッドからpopすることも可能ですが、一つの要素は一つのスレッドにだけ届きます。同じ要素が複数のpopに届くことはありません。
空のQueueに対してpopを行うとpopはブロックします。新しいオブジェクトが追加され、そしてそのオブジェクトを獲得したただ一人のスレッドに対してオブジェクトを届けます。

Dripにおいてpopに相当する操作はreadです。readは指定したカーソルより新しい要素を返します。ただし、Dripの中から要素を削除することはありません。複数のスレッドが同じカーソルでreadした場合には、それぞれのスレッドに同じ要素を返します。
カーソルよりも新しい要素がない場合、readはブロックします。新しいオブジェクトがwriteされるとreadのブロックはとけて、新しい要素を返します。この場合も、複数のスレッドに同じ要素が届きます。

DripがQueueやRindaとよく似ているポイントは、要素の到着を待つことができるところです。

また異なるポイントは要素を消費するかどうかです。Queueのpopは要素を消費しますが、Dripのreadでは要素は減りません。これは何度でも／何人でも読めるということです。Rindaではアプリケーションのバグやクラッシュによるタプルの紛失はシステム全体のダウンを意味することがありますが、Dripでは要素の紛失を気にする必要はありません。

具体的なコードでDripのreadの様子を見ていきましょう。

***ここで使用するメソッド

ここで使用するメソッドは主に二つです。

>|ruby|
Drip#write(obj, *tags)
||<

writeメソッドはDripの状態を変化させる唯一の操作で、要素を追加します。要素objをDripに格納し、格納されたキーを返します。objへのアクセスを容易にするために、複数のタグをしていできます。タグの使い方はあとで説明します。

もう一つのメソッドはreadです。

>|ruby|
Drip#read(key, n=1, at_least=1, timeout=nil)
||<

Dripをブラウズする基本となるメソッドがreadです。keyは注目点（カーソル）で、keyよりも後に追加された要素のキーと値の組をn個の配列で返します。要素がat_least個そろうまで、readはブロックします。timeoutを指定することができます。
説明が長いですね。要するに「新しい要素をn返せ。at_least個揃うまでは待機せよ。」です。


***Dripのインストールと起動

おっと。Dripのインストールを忘れていました。DripはRBTreeという赤黒木の外部ライブラリを使用します。gemを用意していただいたので次のようにインストールして下さい。

>||
% gem ?????
||<

次にDripサーバを起動します。

Dripはデフォルトでは二次記憶としてプレーンなファイルを使います。Dripを生成するにはファイルを置くディレクトリを指定します。次のスクリプト（drip_s.rb）はDripを生成しdRubyでサービスするものです。

>|ruby|
require 'drip'
require 'drb'

class Drip
  def quit
    Thread.new do
      synchronize do |key|
        exit(0)
      end
    end
  end
end

drip = Drip.new('drip_dir')
DRb.start_service('druby://localhost:54321', drip)
DRb.thread.join
||<

Dripにquitメソッドを追加しています。これはRMI経由でこのプロセスを終了させるもので、Dripが二次記憶への操作をしていないとき（synchronize中）を待ってから終わらせます。

次のように起動できます。
>||
% ruby drip_s.rb
||<

***MyDrip

MacOSXなどPOSIXなOS専用ですが、MyDripという1人用の起動が簡単なDripサーバも用意されています。これは、ホームディレクトリの直下に.dripというディレクトリを作成し、この中をストレージとするDripで、UNIXドメインソケットを使ってサービスします。UNIXドメインソケットですから、ファイルの権限、可視性によって利用者を制限できます。また、UNIXドメインソケットのファイル名はホームディレクトリ以下のいつも決まったパスで接続できます。MyDripを利用するにはmy_dripをrequireします。
起動してみましょう。

>||
ターミナル1
% irb -r my_drip --simple-prompt
>> MyDrip.invoke
=> 51252
>> MyDrip.class
=> DRb::DRbObject
||<

MyDripはこの固定のポートを指すDRbObjectですが、特別にinvokeメソッドが定義されています。MyDrip.invokeは新しいプロセスをforkし、必要であればDripデーモン起動します。すでに自分用のMyDripが動いている場合にはなにもせずに終了します。なお、MyDripを終了させるにはMyDrip.quitメソッドを使います。

MyDripはirb実行中にちょっとしたオブジェクトのメモをとるのにも使える便利なデーモンです。筆者の環境ではいつもMyDripを起動してあり、Twitterのタイムラインを常にアーカイブしたり、メモをしたりbotのミドルウェアになったりしています。

以降の実験では、主にMyDripを利用します。MyDripが利用できない環境の方は、次のように定義した"my_drip.rb"を用意することでdrip_s.rbのサービスを代用して使えます。

>|ruby|
MyDrip = DRbObject.new_with_uri('druby://localhost:54321')
||<

***再びQueueとの比較

MyDripデーモン（あるいは代用となるdrip_s.rb）が起動している状態で実験です。

writeメソッドを使ってオブジェクトを二つ追加します。writeはDripを変化させる唯一のメソッドです。writeメソッドの戻り値は追加された要素と関連付けられたキーです。キーは時刻（usec）から作られた正の整数で、64bitマシンではしばらくの間はFixnumとなります。

>||
ターミナル2
% irb -r my_drip --simple-prompt
>> MyDrip.write('Hello')
=> 1312541947966187
>> MyDrip.write('world')
=> 1312541977245158
||<

つぎにDripからデータを読んでみます。

>||
ターミナル3
% irb -r my_drip --simple-prompt
>> MyDrip.read(0, 1)
=> [[1312541947966187, "Hello"]]
||<

readはカーソルからn個の要素を読むメソッドで、キーと値のペアの配列を返します。
順に読むには次のようにカーソルを動かしながらreadすると良いでしょう。

>||
>> k = 0
=> 0
>> k, v = MyDrip.read(k, 1)[0]
=> [1312541947966187, "Hello"]
>> k, v = MyDrip.read(k, 1)[0]
=> [1312541977245158, "World"]
||<

二つ読めました。さらに読むとどうなるでしょう。

>||
>> k, v = MyDrip.read(k, 1)[0]
||<

kよりも新しい要素がないのでブロックします。ターミナル2から新しい要素を追加するとブロックがとけ、そのオブジェクトが読めるはずです。

>||
ターミナル2
>> MyDrip.write('Hello, Again')
=> 1312542657718320
||<

>||
>> k, v = MyDrip.read(k, 1)[0]
=> [1312542657718320, "Hello, Again"]
||<

どうですか？待合せできていますか？

読み手を増やしてまた0から読んでみましょう。

>||
ターミナル4
% irb -r my_drip --simple-prompt
>> k = 0
=> 0
>> k, v = MyDrip.read(k, 1)[0]
=> [1312541947966187, "Hello"]
>> k, v = MyDrip.read(k, 1)[0]
=> [1312541977245158, "World"]
>> k, v = MyDrip.read(k, 1)[0]
=> [1312542657718320, "Hello, Again"]
||<

同じ要素が読めました。DripではQueueとちがって要素を消費しませんから、同じ情報をなんども読めます。その代わりにどの辺りの要素を読むのか、readのたびに指定しなくてはなりません。

ここでMyDripを再起動させましょう。quitメソッドを呼ぶとだれもwriteしていないときを見計らってプロセスを終了させます。再起動するにはinvokeを呼びます。MyDrip.invokeはログが大きいと時間がかかるときがあります。

>||
ターミナル1
>> MyDrip.quit
=> #<Thread:...>
>> MyDrip.invoke
=> 61470
||<

readメソッドで先ほどの状態になっているか確認してみましょう。

>||
ターミナル1
>> MyDrip.read(0, 3)
=> [[1312541947966187, "Hello"], [1312541977245158, "World"], [1312542657718320, "Hello, Again"]]
||<

まとめます。
Queueと似ている点は、時系列に並んだデータを順に取り出せるところ、データの到着を待合せできるところです。Queueと異なる点はデータが減らないところです。同じ要素を複数のプロセスから読めますし、同じプロセスが何度もよむこともできます。経験上、バッチ処理は開発中も運用中も何度も停まりますよね。Dripでは工夫すれば先ほどの状態から処理を再開できます。途中からでも最初からでもやり直すチャンスがあります。



*以下編集中

**Rindaとの違い

PTupleSpaceはTupleSpaceのサブクラスです。タプルの状態の変化を逐次二次記憶にログして、次回の起動に備えます。PTupleSpaceを再起動すると最後の（最新の）タプルの状態のままに復元されます。

タプルは実世界の「伝票」によく似ています。タプルをプロセス間でリレーしながら仕事を進めていく様子は、「伝票」を持ち回って仕事を行うのにそっくりです。Rindaの世界では「伝票」はTupleSpaceを介してプロセスからプロセスへ渡り歩きます。

PTupleSpaceの提供する永続化は、TupleSpaceに蓄えられた伝票の束にのみ作用します。プロセスが持っている伝票をPTupleSpaceが知ることはできず、永続化されません。また、待合せている様子も永続化の対象ではありません。プロセスがある伝票を待っている、という状況までは再現できないのです。

TupleSpaceに期待する機能が伝票の貯蔵庫であると考えた場合には、これで充分と言えるでしょう。PTupleSpaceにwriteした情報は再起動後もそのまま手に入ります。多くのアプリケーションではこれで間に合うかもしれません。ArrayやHashをそのままdRubyで公開する、あるいはログ付きで公開するのに比べて、TupleSpaceはどのくらい便利なのでしょうか。おそらく、RindaのTupleSpaceの強力なパターンマッチングにはある程度のアドバンテージがあるでしょう。そのパターンマッチングと引き換えに、あまり効率のよいデータ構造を使うことができませんでした。実装には線形探索が残っていて、要素数が増えたときに不安があります。

TupleSpaceの本来の役割であるプロセス間の協調についてはどうでしょうか。PTupleSpaceに異常が起きてクラッシュしてしまった、再起動が必要になった、といった状況を想像してみましょう。まず、PTupleSpaceプロセスが停止することにより、readやtakeなどの待合せのRMIを実行していたプロセスではdRubyの例外があがります。PTupleSpaceが再起動されるとタプル群の最後の状態に復元されます。待合せをしていたプロセスは再起動したことを（知るのは難しいのですが）知ったのち、例外が発生した操作をやり直すことになります。しかし、そのように再開するスクリプトを書くのは難しく面倒です。

また、RMIのために抱え込む厄介な問題もあります。writeやtakeなど、タプルの状態を変える操作を考えてみましょう。通常のメソッド呼び出しでは処理が終われば呼び出した側に直ちに制御がもどりますが、RMIではサーバ側のメソッドの終了と、RMIの終了の間にソケット通信が行われます。つまり、処理が終わる前に例外が発生したのか、結果を伝える間に例外が発生したのか知ることができません。PTupleSpaceが二次記憶にタプルの操作をログしたあとに、クライアントにその完了が届く前にクラッシュしてしまう可能性があります。（全てがうまくいってからログする実装を選んでも、クライアントにタプルが届いたのち、ログするまえにクラッシュする可能性があります）

異常終了といえば、プロセス側のクラッシュも考えられますね。PTupleSpaceの対象外ですがちょっと想像してみましょう。伝票をプロセスが取り出したままクラッシュしてしまうと、復元する方法がありません。次の短いスクリプトを見てみましょう。

>|ruby|
def succ
  _, count = @ts.take([:count, nil])
  count += 1
  yield(count)
ensure
  @ts.write([:count, count) if count
end
||<

これは[:count, 整数]のタプルを取り出し、一つ大きくしてまた書き込むスクリプトです。伝票を取り出し、カウンタを一つ進め、最後にTupleSpaceに書き戻します。伝票がプロセスにある間は、別のプロセスは伝票をTupleSpaceから読んだり、取り出したりすることはできないので安全にカウンタを操作できます。さて、もしも伝票がプロセスにある間にそのプロセスがクラッシュしたらどうなるでしょう。PTupleSpaceは自身の中にある伝票しか復元できませんから、その伝票は失われたままです。このカウンタを操作するプロセス群は全て停まってしまいます。こういった使い方（協調に使うケースの多くはそうなんだと思うのですが）をする場合、TupleSpaceだけでなく関係するプロセス群も再起動する必要があるだけでなく、TupleSpace内のタプルも初期状態にする必要があります。せっかくタプルの状態を復元できるようにしたというのに‥。

PTupleSpaceはTupleSpace自体の永続化を目的としたもので、それ自体はおそらく期待した通りに動作すると思います（そういうつもりで作ったので）。しかし、それだけでは協調するプロセス群をもとに戻すことはできません。ちょっとだまされた気分ですよね。

**PTupleSpaceの使い方

skip


**ストレージとしてのTupleSpace

APIの視点からストレージとしてのTupleSpaceをおさらいします。
TupleSpaceはタプル群を扱う集合構造です。同じ情報を複数持つことができるので、Bagと言えるでしょう。
最近の流行言葉にKVSという言葉ありますね。キーと値で表現するなら、同じキーを持つ要素の重複を許すストレージです。キーしかなくて、キーが値、にも見えますが。

これに対してHashは一つのキーに一つの値が関連付けられる辞書です。

TupleSpaceで辞書を模倣するのはやっかいです。[キー, 値]というタプルで辞書を構成仕様とした場合を考えてみましょう。まずデータを読むのは次のように書けそうです。
>|ruby|
@ts.read([キー, nil])
||<
では要素の追加はどうでしょう。
>|ruby|
@ts.write([キー, 値])
||<
このような単純なwriteでは重複を防ぐことはできません。全体をロックして、そのキーのタプルを削除してからwriteする必要があります。
>|ruby|
def []=(key, value)
  lock = @ts.take([:global_lock])
  @ts.take([key, nil], 0) rescue nil
  @ts.write([key, value])
ensure
  @ts.write(lock) if lock
end
||<
このグローバルなロックは実はデータを読むときにも必要です。なぜなら、そのキーの情報を別のスレッドが更新中かもしれないからです。

>|ruby|
def [](key)
  lock = @ts.take([:global_lock])
  _, value = @ts.read([key, nil], 0) rescue nil
  return value
ensure
  @ts.write(lock) if lock
end
||<

要素の増減がないケースでは前章で示した通り、グローバルなロックは不要です。だれかが更新中はその要素は取り出せませんが、更新が終わればまた書き戻されるはずです。ですから、単に要素が読めるまでreadで待ってしまえば良いことになり、局所的なロックとなります。

eachはどのように実装したらよいでしょう。TupleSpace全体を順に走査するうまい方法はありません。read_allで全ての要素のArrayを生成して、その配列にeachを委譲することになります。

>|ruby|
def each(&blk)
  lock = @ts.take([:global_lock])
  @ts.read_all([nil, nil]).each(&blk)
ensure
  @ts.write(lock) if lock
end
||<

要素数が少ないうちは気になりませんが、多くなると損している気がしますね。
分散ハッシュテーブルなどでもeachやkeysを低コストで実装するのは難しいかもしれません。

流行のストレージには、常にキーでソートされているシーケンスを持つものがあります。並んでいることを利用して、大きな空間をブラウズするのが得意です。キーを工夫することでバージョン付きの情報を蓄えることもできます。RindaのTupleSpaceには、タプルを順序付けて並べることはできませんから、これを低コストで模倣するのは難しいです。

ところであなたが欲しかった集合は本当にHashでしたか？

**ストリーム指向のストレージDrip

この節で紹介するのは前章で説明したRD stream（消えないストリーム）のようなデータ構造を持つライブラリDripです。Dripはオブジェクトを書き込まれた順に蓄えるだけでなく、イベント通知メカニズムとしてプロセス間の同期にも使えます。Drip自体の機能は非常に小さいものですが、視点によっていろいろなものに見えます。ストレージにもバッチ処理のミドルウェアにも見えます。ひとことで説明するのは難しいですが、流行のサービスではTwitterのタイムラインがよく似ています。Rubyの標準ライブラリでたとえると、消えないQueue、消えないRindaです。たとえてもやっぱりよくわかりませんね。

簡単なスクリプトを使ってDripを使ってみましょう。

***Dripをインストールする

(井上さんgems化してくださーい。)

***Dripを作る

Dripはデフォルトでは二次記憶としてプレーンなファイルを使います。Dripを生成するにはファイルを置くディレクトリを指定します。次のスクリプト（drip_s.rb）はDripを生成しdRubyでサービスするものです。

>|ruby|
require 'drip'
require 'drb'

class Drip
  def quit
    Thread.new do
      synchronize do |key|
        exit(0)
      end
    end
  end
end

drip = Drip.new('drip_dir')
DRb.start_service('druby://localhost:54321', drip)
DRb.thread.join
||<

Dripにquitメソッドを追加しています。これはRMI経由でこのプロセスを終了させるもので、Dripが二次記憶への操作をしていないとき（synchronize中）を待ってから終わらせます。

このあとの操作のために起動しておきましょう。

ターミナル1
>||
% ruby drip_s.rb
||<

***オブジェクトを覚える

Dripの状態を変更する唯一のメソッドはwriteメソッドです。writeメソッドには覚えたいオブジェクトを指定します。ちょっと書いてみましょう。

ターミナル2
>||
% irb -r drb --simple-prompt
>> drip = DRbObject.new_with_uri('druby://localhost:54321')
=> #<Drip:...>
>> drip.write('Hello, World.')
=> 1308221059579470
||<

ターミナル1で起動したDripサーバへの参照を作り、dripという変数に覚えます。次に'Hello, World.'という文字列をwriteします。writeの戻り値は書き込んだオブジェクトに対応するキーです。キーは単調増加する整数で、たいてい時刻から生成されます。時刻と最新のキーを比べて、最新のキーの方が大きい場合には+1したものをキーとします。多くの場合時刻と相互に変換できると思いますが、「ユーザが時計を設定してしまった問題」や時刻の分解能よりも細かい単位で書き込まれた場合などにはその限りではありません。いずれにしろ、このようなケースでもキーはいつも単調増加となります。
キーがおおよその時刻に変換できるのは、人間があとでデータを調べるときに多少は便利です。Dripには同時にただ一つのオブジェクトだけが書き込めます。さまざまな事象は同時にいくつも発生しますが、Dripがそれを観測するのは同時にはただ一つです。事象が発生した時刻ではなく、Dripがそれを知った時刻と考えて下さい。

writeメソッドはStringに限らず、どんなオブジェクトでも保存できます。ただし、MarshalできないオブジェクトはDRbObjectで保存されますから、取り出して使えるようにするには多少の工夫が必要です。また、あとでオブジェクトを取り出すときのヒントとなる複数のタグを指定できます。タグはStringでなければいけません。

>||
>> drip.write({:text => 'Hello, World', :user => 'm_seki'}, 'greeting', 'test')
=> 1308221460421676
>> drip.write(1308221460421676, 'test')
=> 1308221907348161
||<

この操作では、Hashのオブジェクトに二つのタグ（'greeting, 'test'）を付けて書き込み、次に整数に'test'というタグを付けて書き込んでいます。writeの際に、一つのオブジェクトに複数のタグをつけることができます。タグはDripで一意なものでなく、同じタグを持つオブジェクトがすでにwriteされていても問題ありません。

***read

Dripからデータを読む方法はたくさんありますが、基本となるのはreadです。readの引数は意外なほど多いです。

>|ruby|
read(key, n=1, at_least=1, timeout=nil)
||<

戻り値はキーとオブジェクト、タグからできたArrayのArrayです。読みたい要素数が1であってもArrayが返ります。keyよりも大きなキーを持つ要素をn個返します。at_leastは最低限返して欲しい要素数です。読める要素数がat_leastに達するまで、readはブロックします。timeoutはブロックの期限を指定します。最低でもtimeout秒は待ち、それを越えると例外があがります。nilを指定すると無限に待ちます。

先頭から一つずつ読み進めてみましょう。Dripのキーは正の整数ですから、先頭はキー0の次の要素です。0から二つの要素を読んでみましょう。

>||
>> drip.read(0, 2)
=> [[1308221059579470, "Hello, World."], [1308221460421676, {:text=>"Hello, World", :user=>"m_seki"}, "greeting", "test"]]
||<

0の次のキーを持つ要素（つまり先頭、一番旧い要素）から二つ分の要素が集まってできたArrayが返りました。

次に先頭から順に一つずつ読んでみます。注目点のキーをkとして、kをずらしながらreadしていきましょう。

>||
>> k = 0
=> 0
>> k, v, *tag = drip.read(k)[0]
=> [1308221059579470, "Hello, World."]
>> k, v, *tag = drip.read(k)[0]
=> [1308221460421676, {:text=>"Hello, World", :user=>"m_seki"}, "greeting", "test"]
>> k, v, *tag = drip.read(k)[0]
=> [1308221907348161, 1308221460421676, "test"]
>> k, v, *tag = drip.read(k)[0]
||<

どうでしょうか？ひとつずつ順に取り出せている様子がわかりますか？Dripにおけるデータのブラウズは、キーをずらすことで表現します。readは与えられたキーのすぐ後の要素を返しますから、さっき読んだオブジェクトのキーを与えてreadすることで全ての要素を順に辿ることができます。C言語のstdioライブラリでいうとfseek()とfread()を一度に行うイメージですね。

さて、4回目のreadでブロックしてしまいました。これは注目点のキーより新しい要素が存在しないからです。もう一つ端末を用意して、要素を追加してみましょう。

ターミナル3
>||
% irb -r drb --simple-prompt
>> drip = DRbObject.new_with_uri('druby://localhost:54321')
=> #<Drip:0x0000010086b130>
>> drip.write('Hello, Again.', 'test')
=> 1308222915958300
||<

ターミナル2
>||
=> [1308222915958300, "Hello, Again.", "test"]
||<

うん。ターミナル2のブロックは解け、新しい要素が届いたのがわかります。　

ここでdrip_s.rbを停止させたらどうなるか実験してみましょう。まずターミナル2でreadを行ってブロックさせます。

ターミナル2
>||
>> k, v, *tag = drip.read(k)[0]
||<

続いてdrip_s.rbを[control]+Cなどで停止させます。

ターミナル1
>||
% ruby drip_s.rb
^Cdrip_s.rb:16:in `join': Interrupt
	from drip_s.rb:16:in `<main>'
||<

ターミナル2ではreadの最中にdrip_s.rbが終了したので例外があがります。待ち合わせしているときにサーバが終了すると、待合せは解除されることになります。

>||
DRb::DRbConnError: connection closed
         ....
||<

再びdrip_s.rbを起動してから、readを試してみましょう。

ターミナル1
>||
% ruby drip_s.rb
||<

ターミナル2
>||
>> k, v, *tag = drip.read(k)[0]
||<

そしてターミナル3からもう一つ要素を追加します。ターミナル2のreadが完了し、その要素を読み出すことができるはずです。

ターミナル3
>||
>> drip.write('drip drop')
=> 1308304037358423
||<

ターミナル2
>||
=> [1308304037358423, "drip drop"]
||<

Dripは要素を二次記憶にwriteされたオブジェクトをログしており、次回の起動に備えています。これまでの実験の中でwriteされた5つの要素が本当に残っているかためしましょう。先頭から5つの要素をreadします。keyの最小値から5つの要素をreadするには、read(0, 5)とします。

ターミナル2
>||
>> drip.read(0, 5)
=> [[1308221059579470, "Hello, World."], [1308221460421676, {:text=>"Hello, World", :user=>"m_seki"}, "greeting", "test"], [1308221907348161, 1308221460421676, "test"], [1308222915958300, "Hello, Again.", "test"], [1308304037358423, "drip drop"]]
||<

drip_s.rbが一度終了しても内容が失われてないことが確認できます。

**MyDrip

MyDripはUNIXの仲間でしか利用できませんが、ちょっと便利なモジュールです。ホームディレクトリの直下にログを置き、UNIXドメインソケットでサービスを提供する、自分専用のDripです。
MyDripは特別なメソッドを持つDripへの参照オブジェクト（DRbObject）です。特別なメソッドはinvokeとquitです。この二つのメソッドは実はinvokeはMyDripに、quitはサーバプロセスのDripに定義されていますが、今は細かいことは気にしないで下さい。
MyDripのサーバプロセスを起動するにはinovkeメソッドを使います。

>|ruby|
require 'my_drip'

MyDrip.invoke
||<

すでにサービスを提供するプロセスが存在する場合、このメソッドはなにもしません。上のスクリプトはMyDripを起動して、要素を一つ書き込んでいる例です。
MyDripは ~/.drip/ にデータを置きます。MyDripのサーバプロセスのプロセスIDはpidに書かれています。またportは通信に使うソケットです。なにかトラブルが起きたときは、UNIXの知識を総動員してpidファイルからプロセスを割り出し、portファイルを削除するなど適切に対処してください。

MyDripを終了するにはquitを使います。quitメソッドはMyDripが書き込み中ならそれを待って、安全に終了させます。

.irbrcを次のように設定しておくと、irbからすぐに使えて便利です。

>|ruby|
require 'my_drip'
||<

次の実験はMyDripを使って行います。Windows系の場合にはMyDripの代わりに先の実験で使ったDripサーバと読み替えて下さい。

>|ruby|
MyDrip = DRbObject.new_with_uri('druby://localhost:54321')
||<

**タグとその他のread系API

writeの際につけたタグを使って、読み出す情報をフィルタすることができます。writeでは、一つの情報に複数のタグをつけることができ、read_tagはタグを一つ指定してそのタグを持つ要素だけを読み出すことができます。その他の引数はreadと同じです。

>|ruby|
read_tag(key, tag, n=1, at_least=1, timeout=nil)
||<

Dripでは全ての要素は一直線のストリームとして管理されます。要素はキーと値、複数のタグで構成されて、キーの順に並んでいます。readやread_tagは小さいキーから大きいキーの順にアクセスします。キーはwriteされた時刻を元に計算され、たいてい連続していません。readやread_tagの際に、存在しないキーを与えても問題ありません。そのキーよりも大きなキーを持つ、直近の要素からアクセスを開始します。readは与えたキーよりも大きなキーを持つ、直近の要素を返します。read_tagも同様に直近の要素を返しますが、タグがマッチしない要素はスキップされ、マッチした要素だけが返されます。タグを使うと一つのDripをタグで分類されたたくさんのDripのように見立てることもできます。
また、readとread_tagのキーは共通ですから二つを組み合わせることもできます。例えば、read_tagで狙ったタグを持つ要素を取得して、それ以降の要素をreadで順に全て集める、といった操作です。

read_tagもreadと同様に要素が取り出せない場合に、ブロックして新しい要素の到着を待つことができます。

read系のAPIは他にも用意されています。

>|ruby|
older(key, tag=nil)

head(n=1, tag=nil)
||<

readやread_tagは過去から未来へ走査するAPIですが、olderとheadは過去方向への操作を補助するAPIです。
olderはkeyで指定した要素の一つ旧い要素を返します。tagを使って要素をフィルタすることもできます。keyにnilを与えると最新を指定したことになります。older(nil)は最新の要素を一つ返します。

headはolderを使ったコンビニエンスメソッドです。一番新しい要素までのn個を返します。tagを使って要素をフィルタすることも可能です。nが1の場合、一番新しい要素だけが入ったArrayを返します。nが2の場合には、一番新しい要素の一つ旧い要素と、一番新しい要素の入ったArrayを返します。Arrayの中は旧いから新しいものへと並んでいます。

過去へ向かってのアクセスはブロックすることはありません。なぜなら、過去には情報が追加できないからです。（要素が増えるのは未来方向のみ）

コンビニエンスメソッドとしてはolderの対になるnewerもあります。

>|ruby|
newer(key, tag=nil)
||<

これは単なるread/read_tagのラッパーで、read(key, 1, 0)[0]あるいはread_tag(key, tag, 1, 0)[0]を簡単に呼べるようにしたものです。

タグとheadを使うとHashのようなデータ構造を実現できます。MyDripを使って実験しましょう。

>||
% irb -r my_drip --simple-prompt
>> MyDrip.invoke
=> 29561
||<

ここでひと呼吸おきます。たくさんのデータが入ってると時間がかかるときがあるからです。

>||
>> MyDrip.write(29, 'seki.age')
=> 1311333836676452
||<



**APIの設計指針

DripはdRubyと組み合わせて使うのを前提としてAPIを設計しました。dRubyの弱点はいくつかありますが、特に苦手なのはサーバ側のオブジェクトの寿命と排他制御の管理、そしてRMIの遅さです。サーバ側に状態をもつオブジェクトを作らないこと、RMIの回数を減らすことはAPIの選択の指針となります。

さきほどのreadメソッドに与えるキーについて、もう一度よく見てみましょう。readのキーは、データベース中の視点、カーソル、ページといった概念に近いものです。よくあるデータベースのAPIでは「カーソル」はコンテキストの中に隠されています。例えばRubyのFileオブジェクトは現在の位置を覚えていて、ファイル中のその位置から読んだり、その位置へ書いたりします。これに対し、DripではFileオブジェクトのような状態／コンテキストをもつオブジェクトを用いません。Dripへの質問は状態の変化を伴わない、関数のようになっています。位置などのコンテキストを管理するオブジェクトの代わりに、注目点となるキーを使うのです。このAPIを選択した理由は、コンテキストを管理するオブジェクトをDripサーバの中で生成しないためです。DripはdRubyを経由したRMIで利用されることを前提としています。生成と消滅（beginとend、openとclose）があるようなコンテキストを導入すると、その寿命をサーバが気にする必要が生まれます。分散環境でのGCといった難しい問題に向かい合わなくてはなりません。このため、Dripではそのような面倒を嫌ってInteger（キー）だけの付き合いとなるようにAPIを設計しました。
この節で示した通り、コンテキストを管理するオブジェクトを使う代わりに、readのたびに返されるキーを使ってアクセスすることで、同様な操作を実現できます。もしこのAPIでの操作が面倒と感じるなら、ローカルなプロセスの中でキーを隠すようなコンテキストを準備することを勧めます。間違ってDripサーバ側にコンテキストを用意しないよう注意して下さいね。

readでは、自分の知らない情報を一度に最大n個、少なくともm個を返せ、と指示します。n回のreadで構成すると、RMIの回数が増えてしまいますが、このように一度に転送すればRMIの回数を削減できます。応答時間よりも処理時間が重要なバッチ処理などのケースで有効です。「少なくともm個」を指定することで、イベントの（データの）発生の都度RMIを発生させずにすみます。ほどほどにデータがたまるのを待って一度に転送することができるからです。

Dripはストレージに関する一連の習作の経験から、「作りすぎない」ことに留意しました。「作る」ことは楽しいので、請われるままに機能を増やしてしまうことがしばしば起こります（私はそういう経験があります）。Dripのポリシーを明確にして、機能を増やしてしまう誘惑と戦いました。


**通信と緩衝材

複数のプロセスが通信しあうプログラミングでは、相互の都合の折り合いをつけるために、いろいろな意味合いのバッファを導入します。それはselect()の類の待合せだったり、read/writeのためのバッファ（メモリの）だったり、さまざまなレイヤー間でパケットが組み上がるのを待ったり、通知したり、そういうものです。

